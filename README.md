Dagger 2 기본 사용법 (아주 기초)

사실 Dagger 2는 2018년도 당시 현장실습을 다녔을 때 해당 회사의 팀장님께서 '이런 것이 있으니까 한번 해봐라. 많은 도움이 될 것이다.' 라고 했던 것이다.

그래서 나는 이미 Dagger 2의 존재를 알고 있었다.

하지만 진행을 해보면서 러닝커브가 너무 높고 여기저기 지식을 찾아본 결과 지식이 뭐랄까... 파편화 되어있다는 생각이 들어서 잘못된 지식을 넣지 말고 있다가 진행을 하자 라는 생각이 들었다.

나중에 회사에서 입사를 하고 같이 개발에 대해서 이야기하는 개발자 동료랑 이야기하고 있을 때 '병갑아. 요즘 안드로이드 개발자 신입은 rx + Dagger 2 + mvvm'이래 라고 한 적이 있었다.

문득 Dagger2를 미루고 있었지만 이제는 어느정도 날짜도 지나서 지식들이 한 곳에 모여있는 곳도 있겠다고 판단해 이렇게 Dagger2의 기본 지식을 잡아볼 필요가 있다 생각해 이 Repository를 만들었다.

의존성 주입! Dagger2로 익혀보자!


//===================================================
22.02.01

항상 모든 기술들은 지금보다 더 나은 환경을 구축하면서 발전한다고 생각한다. 이것은 모든 기술들도 그렇고 지금 쓰고있는 '의존성 주입'도 다를 바가 없다.

기본적인 객체 생성은 말 그대로 직접 객체를 참조하여 생성한다.
ex) Math math = new Math()
ex) val math: Math = Math()

하지만 이것은 다양한 클래스를 문어발적으로 사용하는 과정이 되어버리고 만약에 커스텀한 클래스 중 어느 한 클래스에 수정이 필요하게 된다고 하면 해당 클래스를 참조하는 코드가 n개면 n번 고쳐줘야 되는 것이다.

이 과정은 결국 독립적인 컴포넌트로 이룩할 수 없다. 온전히 혼자서 활동할 수 없는 것이다. 때문에 이는 결국에는 결합도가 높아진, 객체지향이 추구하는 바와는 어울리지 않는 형태가 되어버리고 만다.

때문에 이것을 고치기 위하여 만들어진 것이 '의존성 주입'이라는 개념인데 간단하게 말해서 기존에는 직접 제공하는 사람을 찾아갔다면 이제는 중개인을 거쳐 중개인이 대신 도와주는 것이다.

객체를 직접 참조하는 형태(val math: Math = Math())를 도식화해보자면



제공하는 놈 -> 제공받는 놈



단순하다. 하지만 이제는 컴포넌트라고 하는 중개인이 끼게 된다.

이를 도식화해보자면



Module(제공하는 놈) -> Component(연결해주는 놈) -> Inject(제공받는 놈)



이 되는 것이다.

Module은 해당 클래스를 제공해주는 놈이다.

inject하는 변수가 어떤 클래스를 참조할 지 정할 때 Module에서 해당 클래스를 찾아 참조하게 된다.

Component는 해당 Module을 어느 액티비티 혹은 프래그먼트에 연결을 할 지 정하는 놈이다.

말 그대로 A Module을 B라는 액티비티에 연결할거에요! 라고 interface에 함수로 적어놓으면 된다. 이 중개인이 이러한 함수로 이런 모듈을 제공해줍니다. 라고 광고하는 느낌이다.

Inject는 실제로 제공을 받게되는 놈이다. 말 그대로 고객이다 고객. 어떤 거 주문하면 연결된 모듈에서 클래스를 찾아서 들어가는 것이다.

말 그대로 특징은 찢어졌다는 것이다. 지금까진 문어발이었지만 이제는 문어발이 아니고 나름의 체계가 잡혔다. 체계가 잡혔다는 것은 결국 응집도가 더욱 높아지고 결합도는 더욱 낮아졌다는 것을 의미한다.

여기(의존성 주입)에 대한 장단점은 뻔하다.



1. 클래스를 독립적으로 개발 가능하고 테스트가 쉬워진다.

이미 찢어져 있는 친구라는 것이다. 그렇다는 것은 결국 독립적으로 개발 하고 이것저것으로 붙여서 바로 테스트해볼수도 있는것이다. 그리고 테스트로 바뀌어지는 영향력 또한 적어진다는 것이다. 어느 다른 곳에서 뭐 바꾸고 이러지 않아도 된다 이거다.



2. 주입하는 코드만 변경하면 된다.

이미 내가 주입하는 모듈에서만 바꾸면 나머지가 다 바뀐다. 이것은 다시 말해서 이전에 참조했던 방식인 직접 참조를 했는데 해당 코드가 100개 있으면 100번 바꿔야된다는 말이 된 것이다. 하지만 이제는 아니다. 1번만 교체하면 100개가 다 바뀐다.



눈에 띄게 보이는 것은 이 정도인것 같다.

하지만 찢어졌다는 것이 마냥 좋은 것은 아니다.

단점도 명확하다.



1. 간단한 프로그램 같은 경우는 오히려 복잡해지게 된다.

말 그대로다. 배보다 배꼽이 더 크게 될 수도 있다는 것이다. 객체 하나 참조시키자고 모듈 하나 만들고, 컴포넌트 하나 만들어서 주입하는 코드까지 만들어야된다는 것이다. 와 몇개야 이게...



2. 코드 추적이 복잡해지게 된다.

찢어졌다는 것은 그만큼 거쳐가야 되는 곳도 많다는 것이다. 징검다리가 많다는 것이다. 만약 4개로 찢었으면 점프를 4번 해야되는 것이다. 이는 한번에 할 수 있는 행동을 여러번으로 쪼갠 결과기도 하다.



결론

정말 좋은 자료인 것 맞다. 하지만 모든 것은 다 적시적소가 있는 법. 닭 잡는 데 소 잡는 칼 쓰면 괜한 힘 빼는 일이 될 것이고, 소 잡는 데 닭 잡는 칼 쓰면 시간이 오래 걸릴 것이다. 뭐든 사이즈에 맞게 행동하자.
